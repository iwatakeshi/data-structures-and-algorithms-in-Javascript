{"version":3,"sources":["Chapter 8/Binary Tree/index.js"],"names":[],"mappings":";;;;;;;;;;;;oBAAiB,SAAS;;;;IAEpB,UAAU;AACH,WADP,UAAU,GACA;0BADV,UAAU;;AAEV,QAAI,CAAC,IAAI,GAAG,SAAS,CAAC;GACvB;;;;;;;;eAHC,UAAU;;WASV,cAAC,GAAG,EAAE;AACR,UAAI,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;AACxB,aAAO,OAAO,CAAC,GAAG,KAAK,GAAG,EAAE;;AAE1B,YAAI,GAAG,GAAG,OAAO,CAAC,GAAG,EAAE,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC;;aAEzC,OAAO,GAAG,OAAO,CAAC,KAAK,CAAC;;AAE7B,YAAI,CAAC,OAAO,EAAE,OAAO,SAAS,CAAC;OAChC;AACD,aAAO,OAAO,CAAC;KAChB;;;WAEK,gBAAC,GAAG,EAAE,KAAK,EAAE;AACjB,UAAI,IAAI,GAAG,uBAAU,CAAC;AACtB,UAAI,CAAC,GAAG,GAAG,GAAG,CAAC;AACf,UAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AACnB,UAAI,CAAC,IAAI,CAAC,IAAI,EACZ,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KACd;AACH,YAAI,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;AACxB,YAAI,QAAM,YAAA,CAAC;AACX,eAAO,IAAI,EAAE;AACX,kBAAM,GAAG,OAAO,CAAC;;AAEjB,cAAI,GAAG,GAAG,OAAO,CAAC,GAAG,EAAE;AACrB,mBAAO,GAAG,OAAO,CAAC,IAAI,CAAC;;;;AAIvB,gBAAI,CAAC,OAAO,EAAE;AACZ,sBAAM,CAAC,IAAI,GAAG,IAAI,CAAC;AACnB,qBAAO;aACR;;WAEF,MAAM;AACL,qBAAO,GAAG,OAAO,CAAC,KAAK,CAAC;;;;AAIxB,kBAAI,CAAC,OAAO,EAAE;AACZ,wBAAM,CAAC,KAAK,GAAG,IAAI,CAAC;AACpB,uBAAO;eACR;aACF;SACF;OACF;KACF;;;WAEK,gBAAC,GAAG,EAAE;AACV,UAAI,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;AACxB,UAAI,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC;AACvB,UAAI,WAAW,GAAG,KAAK,CAAC;;AAExB,UAAM,KAAK,GAAG,SAAR,KAAK,CAAa,IAAI,EAAE;AAC5B,YAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,EAC3B,OAAO;AACL,iBAAO,EAAE,CAAC;AACV,kBAAQ,EAAE;AACR,gBAAI,EAAE,KAAK;AACX,iBAAK,EAAE,KAAK;WACb;SACF,CAAC;AACJ,YAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,EAC1B,OAAO;AACL,iBAAO,EAAE,CAAC;AACV,kBAAQ,EAAE;AACR,gBAAI,EAAE,IAAI;AACV,iBAAK,EAAE,KAAK;WACb;SACF,CAAC;AACJ,YAAI,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,EAC1B,OAAO;AACL,iBAAO,EAAE,CAAC;AACV,kBAAQ,EAAE;AACR,gBAAI,EAAE,KAAK;AACX,iBAAK,EAAE,IAAI;WACZ;SACF,CAAC;AACJ,YAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,EACzB,OAAO;AACL,iBAAO,EAAE,CAAC;AACV,kBAAQ,EAAE;AACR,gBAAI,EAAE,IAAI;AACV,iBAAK,EAAE,IAAI;WACZ;SACF,CAAC;OACL,CAAC;;AAEF,UAAM,OAAO,GAAG,SAAV,OAAO,CAAa,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE;AACrD,YAAI,OAAO,KAAK,IAAI,EAAE,IAAI,GAAG,IAAI,CAAC,KAC7B,IAAI,WAAW,EAAE,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,KACpC,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC;OAC1B,CAAC;;AAEF,UAAM,YAAY,GAAG,SAAf,YAAY,CAAa,IAAI,EAAE;AACnC,YAAI,OAAO,GAAG,IAAI,CAAC;AACnB,YAAI,UAAU,GAAG,IAAI,CAAC;AACtB,YAAI,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;AAC1B,eAAO,CAAC,CAAC,QAAQ,EAAE;AACjB,iBAAO,GAAG,UAAU,CAAC;AACrB,oBAAU,GAAG,QAAQ,CAAC;AACtB,kBAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC;SAC1B;AACD,YAAI,UAAU,KAAK,IAAI,CAAC,KAAK,EAAE;AAC7B,iBAAO,CAAC,IAAI,GAAG,UAAU,CAAC,KAAK,CAAC;AAChC,oBAAU,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;SAC/B;AACD,eAAO,UAAU,CAAC;OACnB,CAAC;;;AAGF,aAAO,GAAG,KAAK,OAAO,CAAC,GAAG,EAAE;AAC1B,cAAM,GAAG,OAAO,CAAC;AACjB,YAAI,GAAG,GAAG,OAAO,CAAC,GAAG,EAAE;AACrB,qBAAW,GAAG,IAAI,CAAC;AACnB,iBAAO,GAAG,OAAO,CAAC,IAAI,CAAC;SACxB,MAAM;AACL,qBAAW,GAAG,KAAK,CAAC;AACpB,iBAAO,GAAG,OAAO,CAAC,KAAK,CAAC;SACzB;AACD,YAAI,CAAC,OAAO,EAAE,OAAO,KAAK,CAAC;OAC5B;AACD,cAAQ,KAAK,CAAC,OAAO,CAAC,CAAC,OAAO;AAC9B,aAAK,CAAC;AACJ,iBAAO,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC;AAC/C,gBAAM;AAAA,AACR,aAAK,CAAC;AACJ,cAAI,KAAK,CAAC,OAAO,CAAC,CAAC,QAAQ,CAAC,IAAI,EAC9B,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,KAC/C,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;AACxD,gBAAM;AAAA,AACR,aAAK,CAAC;AACJ,cAAI,SAAS,GAAG,YAAY,CAAC,OAAO,CAAC,CAAC;AACtC,iBAAO,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC;AAC/C,mBAAS,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;AAC9B,gBAAM;AAAA,OACP;AACD,aAAO,IAAI,CAAC;KACb;;;SApJG,UAAU;;;qBAuJD,UAAU","file":"Chapter 8/Binary Tree/index.js","sourcesContent":["import Node from '../Node';\n\nclass BinaryTree {\n  constructor() {\n      this.root = undefined;\n    }\n    /**\n     * Searches for the node with the specified key\n     * @param  {Number} key The key to the node\n     * @return {Node}     The node\n     */\n  find(key) {\n    let current = this.root;\n    while (current.key !== key) {\n      // Go left\n      if (key < current.key) current = current.left;\n      // Go right\n      else current = current.right;\n\n      if (!current) return undefined;\n    }\n    return current;\n  }\n\n  insert(key, value) {\n    let node = new Node();\n    node.key = key;\n    node.value = value;\n    if (!this.root)\n      this.root = node;\n    else {\n      let current = this.root;\n      let parent;\n      while (true) {\n        parent = current;\n        // Go left\n        if (key < current.key) {\n          current = current.left;\n          // If the current is undefined,\n          // then we have found a spot to\n          // insert the node\n          if (!current) {\n            parent.left = node;\n            return;\n          }\n          // Go right\n        } else {\n          current = current.right;\n          // If the current is undefined,\n          // then we have found a spot to\n          // insert the node\n          if (!current) {\n            parent.right = node;\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  remove(key) {\n    let current = this.root;\n    let parent = this.root;\n    let isLeftChild = false;\n    // Checks whether the node have\n    const check = function (node) {\n      if (!node.left && !node.right)\n        return {\n          chilren: 0,\n          position: {\n            left: false,\n            right: false\n          }\n        };\n      if (node.left && !node.right)\n        return {\n          chilren: 1,\n          position: {\n            left: true,\n            right: false\n          }\n        };\n      if (!node.left && node.right)\n        return {\n          chilren: 1,\n          position: {\n            left: false,\n            right: true\n          }\n        };\n      if (node.left && node.right)\n        return {\n          chilren: 2,\n          position: {\n            left: true,\n            right: true\n          }\n        };\n    };\n    // Sets the node\n    const setNode = function (current, root, parent, node) {\n      if (current === root) root = node;\n      else if (isLeftChild) parent.left = node;\n      else parent.right = node;\n    };\n\n    const getSuccessor = function (node) {\n      let _parent = node;\n      let _successor = node;\n      let _current = node.right;\n      while (!!_current) {\n        _parent = _successor;\n        _successor = _current;\n        _current = _current.left;\n      }\n      if (_successor !== node.right) {\n        _parent.left = _successor.right;\n        _successor.right = node.right;\n      }\n      return _successor;\n    };\n\n    // Search for the node\n    while (key !== current.key) {\n      parent = current;\n      if (key < current.key) {\n        isLeftChild = true;\n        current = current.left;\n      } else {\n        isLeftChild = false;\n        current = current.right;\n      }\n      if (!current) return false;\n    }\n    switch (check(current).chilren) {\n    case 0:\n      setNode(current, this.root, parent, undefined);\n      break;\n    case 1:\n      if (check(current).position.left)\n        setNode(current, this.root, parent, current.left);\n      else setNode(current, this.root, parent, current.right);\n      break;\n    case 2:\n      let successor = getSuccessor(current);\n      setNode(current, this.root, parent, successor);\n      successor.left = current.left;\n      break;\n    }\n    return true;\n  }\n}\n\nexport default BinaryTree;"],"sourceRoot":"/source/"}